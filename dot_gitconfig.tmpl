[alias]
    a   = commit --amend
    br  = branch
    c   = commit
    ca  = !git add -A && git commit         # Commit all changes.
    co  = checkout
    cp  = cherry-pick
    d   = diff
    dc  = diff --cached
    f   = fetch
    g   = log --graph --pretty=custom       # Show custom graph.
    l   = log --pretty=custom               # Show custom log.
    lc  = shortlog --summary --numbered     # List contributors.
    p   = push
    r   = rebase
    rlc = reset --hard HEAD~1               # Remove last commit.
    s   = status
    ulc = reset --soft HEAD~1               # Undo last commit.
    w   = instaweb --httpd=webrick          # Start web-based visualizer.

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Find commits by source code.

    cc = "!f() { \
        git log --pretty=custom --decorate --date=short -S\"$1\"; \
    }; f"

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Find commits by commit message.

    cm = "!f() { \
        git log --pretty=custom --decorate --date=short --grep=\"$1\"; \
    }; f"

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Credit an author on the latest commit.

    credit = "!f() { \
        if [ -n \"$1\" ] && [ -n \"$2\" ]; then \
            git commit --amend --author \"$1 <$2>\" -C HEAD; \
        fi \
    }; f"

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # List remote branches.

    lrb = "!f() { \
        remote="${1:-origin}"; \
        git ls-remote --heads "$remote"; \
    }; f"

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Merge GitHub pull request on top of the current branch or,
    # if a branch name is specified, on top of the specified branch.

    mpr = "!f() { \
        declare currentBranch=\"$(git symbolic-ref --short HEAD)\"; \
        declare branch=\"${2:-$currentBranch}\"; \
        if [ $(printf \"%s\" \"$1\" | grep '^[0-9]\\+$' > /dev/null; printf $?) -eq 0 ]; then \
            git fetch origin refs/pull/$1/head:pr/$1 && \
            git checkout -B $branch && \
            git rebase $branch pr/$1 && \
            git checkout -B $branch && \
            git merge pr/$1 && \
            git branch -D pr/$1 && \
            git commit --amend -m \"$(git log -1 --pretty=%B)\n\nClose #$1\"; \
        fi \
    }; f"

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Remove the tag with the specified tag name if
    # exists and tag the latest commit with that name.

    retag = "!f() { \
        git tag -d "$1" &> /dev/null; \
        git tag $1; \
    }; f"
	alias = config --get-regexp ^alias\\.


[color "branch"]
    current = green bold
    local = green
    remote = yellow

[color "diff"]
    frag = magenta
    meta = yellow
    new = green
    old = red

[color "status"]
    added = green reverse
    changed = yellow reverse
    untracked = red reverse

[core]
    abbrev = 12
    attributesfile = ~/.gitattributes
    autocrlf = input
    editor = code -w
    excludesfile = ~/.gitignore


[pretty]
    custom = "%C(magenta)%h%C(red)%d %C(yellow)%ar %C(green)%s %C(yellow)(%an)"
    #                     ¦        ¦            ¦            ¦             +- author name
    #                     ¦        ¦            ¦            +- message
    #                     ¦        ¦            +- date (relative)
    #                     ¦        +- decorations (branch, heads or tags)
    #                     +- hash (abbreviated)


[push]
    followTags = true

[filter "lfs"]
	required = true
	clean = git-lfs clean -- %f
	smudge = git-lfs smudge -- %f
	process = git-lfs filter-process

[diff]
    tool = vscode
[difftool "vscode"]
    cmd = code -n -w --diff \"$LOCAL\" \"$REMOTE\"
    trustExitCode = false

[merge]
    tool = vscode
[mergetool "vscode"]
    cmd = code -n -w $MERGED

{{ if eq .work "n" }}
[user]
    name = {{ .realname }}
    email = {{ .email }}
{{ end }}